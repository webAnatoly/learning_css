.composition {
  position: relative;
  &__photo {
    width: 55%;
    box-shadow: 0 1.5rem 4rem rgba($color-black, .4);
    border-radius: 2px;
    position: absolute;
    z-index: 10;
    transition: all .2s;
    outline-offset: 2rem;

    &--p1 {
      left: 0;
      top: -2rem;
    }

    &--p2 {
      right: 0;
      top: 2rem;
    }

    &--p3 {
      left: 20%;
      top: 10rem;
    }

    &:hover {
      outline: 1.5rem solid $color-primary;
      transform: scale(1.05) translate(-.5rem);
      box-shadow: 0 2.5rem 4rem rgba($color-black, .5);
      z-index: 20;
    }
  }

  &:hover &__photo:not(:hover) { // select all others img except hovered one. Note hover under parent div here.
    // transform: scale(.95);
  }
  // composition:hover composition__photo:not(:hover)
  /* Оказывается hover срабатывает даже если мы водим над дочерним элементом, даже если этот дочерний элемент смещен за пределы родительского. 
  Например
    <div class="parent">
      <div class="child">
    </div>
    .parent {
      border: 1px solid red;
      widht: 300px;
      height: 20px;
    }
    .parent:hover { background-color: red; }
    .child {
      margin-top: -200px;
      width: 100px;
      height: 100px;
      background-color: lightgrey;
    }

    В этом примере child будет за пределами parent и если мы поводим над child,
    то ховер всё-равно сработает, так как будто мы поводили непосредственно над родителем.
    
    То же самое происходит и в нашем случае с картинками, которые являются дочерними элементами блока.composition
    и, не смотря на то что его высота равна нулю, ховер срабатывает, потому что такой механизм реализован в браузере (в соответствии со стандартом, видимо).
    Итого селектор "composition:hover composition__photo:not(:hover)" выбирает все картинки с классом "composition__photo", кроме той над которой водим.

  */
}